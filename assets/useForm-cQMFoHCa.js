var oe=Object.defineProperty;var ie=(t,e,r)=>e in t?oe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var i=(t,e,r)=>(ie(t,typeof e!="symbol"?e+"":e,r),r);import{r as o,R as Ve}from"./index-uubelm5h.js";const B=(t,e)=>{const r={...t};return delete r[e],r};class b{constructor({graph:e,dimensions:r,data:u}){i(this,"data",null);i(this,"dimensions");i(this,"getDimensions",()=>this.dimensions);i(this,"get",()=>this.data);i(this,"getAtCoordinates",e=>e!=null&&e.length?e.reduce((r,u)=>r==null?void 0:r[u],this.data)??null:this.data);i(this,"getVertex",e=>this.getAtCoordinates(e));i(this,"set",e=>(this.data=e,e));i(this,"setAtCoordinates",(e,r)=>this.updateAtCoordinates(()=>e,r));i(this,"setVertex",(e,r)=>this.setAtCoordinates(e,r));i(this,"update",e=>{const r=e(this.data);return this.data=r,r});i(this,"updateAtCoordinates",(e,r)=>{const u=e(this.getAtCoordinates(r),r);if(r!=null&&r.length){const A=r.reduceRight((V,l,d)=>({...this.getAtCoordinates(r.slice(0,r.length-(d+1))),[l]:V}),u);return this.data=A,this.getAtCoordinates(r)}else return this.data=u,this.data});i(this,"updateVertex",(e,r)=>this.updateAtCoordinates(e,r));i(this,"clear",()=>{this.data=null});i(this,"pruneAtCoordinates",e=>{e!=null&&e.length?this.updateAtCoordinates(r=>r?B(r,e.at(-1)):null,e.slice(0,-1)):this.data=null});i(this,"pruneVertex",e=>{e!=null&&e.length?this.updateAtCoordinates(r=>r?B(r,e.at(-1)):null,e.slice(0,-1)):this.data=null});i(this,"map",e=>e(this.data));i(this,"mapAtCoordinates",(e,r)=>e(this.getAtCoordinates(r),r));i(this,"mapVertex",(e,r)=>this.mapAtCoordinates(e,r));i(this,"_forEachVertex",(e,r)=>{if(this.dimensions===0)this.data&&e(this.data);else{const u=r.length+1,A=this.getAtCoordinates(r),V=Object.keys(A??{}).map(l=>+l);u===this.dimensions?V.forEach(l=>{const d=[...r,l];e(this.getVertex(d),d)}):V.forEach(l=>this._forEachVertex(e,[...r,l]))}});i(this,"forEachVertex",e=>this._forEachVertex(e,[]));i(this,"_updateAllVertices",(e,r)=>{if(this.dimensions===0){const u=e(this.data);return this.data=u,u}else{const u=r.length+1,A=this.getAtCoordinates(r),V=Object.keys(A??{}).map(l=>+l);return u===this.dimensions?V.reduce((l,d)=>({...l,[d]:this.updateVertex(e,[...r,d])}),{}):V.reduce((l,d)=>({...l,[d]:this._updateAllVertices(e,[...r,d])}),{})}});i(this,"_someVertex",(e,r)=>{if(this.dimensions===0)return this.data?e(this.data):!1;{const u=r.length+1,A=this.getAtCoordinates(r),V=Object.keys(A??{}).map(l=>+l);return u===this.dimensions?V.some(l=>e(this.getVertex([...r,l]))):V.some(l=>this._someVertex(e,[...r,l]))}});i(this,"someVertex",e=>this._someVertex(e,[]));i(this,"updateAllVertices",e=>(this._updateAllVertices(e,[]),this.data));i(this,"setAllVertices",e=>{this._updateAllVertices(()=>e,[])});i(this,"_mapAllVertices",(e,r)=>{if(this.dimensions===0)return this.data===null?null:e(this.data);{const u=r.length+1,A=this.getAtCoordinates(r),V=Object.keys(A??{}).map(l=>+l);return u===this.dimensions?V.reduce((l,d)=>({...l,[d]:this.mapVertex(e,[...r,d])}),{}):V.reduce((l,d)=>({...l,[d]:this._mapAllVertices(e,[...r,d])}),{})}});i(this,"mapAllVertices",e=>new b({dimensions:this.dimensions,data:this._mapAllVertices(e,[])}));u&&r!==void 0?(this.data=u,this.dimensions=r):e?(this.data=e.get(),this.dimensions=e.getDimensions()):r!==void 0?this.dimensions=r:this.dimensions=0}}const q=({dimensions:t=0,initial:e}={})=>{const[r,u]=o.useState(e??new b({dimensions:t})),A=o.useCallback(g=>u(p=>{const x=new b({graph:p});return x.update(g),x}),[]),V=o.useCallback((g,p)=>u(x=>{const w=new b({graph:x});return w.updateAtCoordinates(g,p),w}),[]),l=o.useCallback((g,p)=>u(x=>{const w=new b({graph:x});return w.updateVertex(g,p),w}),[]),d=o.useCallback(g=>A(()=>g),[A]),_=o.useCallback((g,p)=>V(()=>g,p),[V]),v=o.useCallback((g,p)=>l(()=>g,p),[l]),E=o.useCallback(g=>u(p=>{const x=new b({graph:p});return x.updateAllVertices(g),x}),[]),f=o.useCallback(g=>{u(p=>{const x=new b({graph:p});return x.pruneAtCoordinates(g),x})},[]),I=o.useCallback(g=>{u(p=>{const x=new b({graph:p});return x.pruneVertex(g),x})},[]),R=o.useCallback(g=>E(()=>g),[E]),D=o.useCallback(()=>{u(g=>{const p=new b({graph:g});return p.clear(),p})},[]);return[r.get(),{getAtCoordinates:r.getAtCoordinates,getVertex:r.getVertex,set:d,setAtCoordinates:_,setVertex:v,update:A,updateAtCoordinates:V,updateVertex:l,clear:D,pruneAtCoordinates:f,pruneVertex:I,map:r.map,mapAtCoordinates:r.mapAtCoordinates,mapVertex:r.mapVertex,forEachVertex:r.forEachVertex,someVertex:r.someVertex,setAllVertices:R,updateAllVertices:E,mapAllVertices:r.mapAllVertices}]},U=t=>"type"in t&&t.type==="file",W=t=>"type"in t&&t.type==="radio",z=t=>"type"in t&&t.type==="checkbox",pe=t=>"type"in t&&t.type==="date",H=t=>"type"in t&&t.type==="number",ge=t=>"type"in t&&t.type==="select-one",J=t=>"type"in t&&t.type==="select-multiple",de=t=>"type"in t&&t.type==="textarea",L=t=>Array.from(t.options).reduce((e,r)=>r.selected?[...e,r.value]:e,[]),Ce=t=>{if(t)return console.log(t,t.type),W(t)||z(t)?t.defaultChecked??t.checked:U(t)?t.files:H(t)?t.defaultValue?+t.defaultValue:+t.value:ge(t)?t.value:J(t)?L(t):de(t)?t.value:"defaultValue"in t?t.defaultValue??t.value:t.value},xe=t=>{if("target"in t&&"type"in t.target){const e=t.target;return W(e)||z(e)?e.checked:U(e)?e.files:H(e)?+e.value:J(e)?L(e):e.value}},re=t=>t==null||t===""||typeof t=="object"&&"length"in t&&t.length===0,te=t=>!re(t),se=t=>{if(t.ref.current&&"type"in t.ref.current){const e=t.ref.current;return W(e)||z(e)?e.checked:U(e)?e.files:H(e)?te(e.value)?+e.value:e.value:pe(e)?te(e.value)?new Date(e.value):e.value:J(e)?L(e):e.value}return t.value},K=t=>t.mapAllVertices(e=>e?Object.keys(e).reduce((r,u)=>u?{...r,[u]:se(e[u])}:r,{}):null),Ae=(t,e)=>{const{ref:r,onChange:u,onBlur:A,onFocus:V}={ref:e.ref??"ref",onChange:e.onChange??"onChange",onBlur:e.onBlur??"onBlur",onFocus:e.onFocus??"onFocus"};return{[r]:t.ref,[u]:t.onChange,[A]:t.onBlur,[V]:t.onFocus}},fe=(t,e)=>(r,u)=>Ae(t(r,u),e),we=({dimensions:t=0,isRequiredErrorMessageOverride:e,shouldNotAutoPruneFields:r=!1}={})=>{const u=o.useRef(new b({dimensions:t})),[A,{updateVertex:V,set:l,pruneVertex:d,pruneAtCoordinates:_}]=q({dimensions:t}),[v,{someVertex:E,updateVertex:f,pruneVertex:I,pruneAtCoordinates:R}]=q({dimensions:t}),[D,{someVertex:g,updateVertex:p,updateAllVertices:x,pruneVertex:w,pruneAtCoordinates:Q}]=q({dimensions:t}),ne=o.useMemo(()=>!!v&&E(n=>n?Object.values(n).some(s=>s):!1),[v,E]),ue=o.useMemo(()=>!!D&&g(n=>n?Object.values(n).some(s=>s):!1),[D,g]),y=o.useCallback((n,s,a)=>u.current.updateVertex(c=>c?{...c,[n]:s(c==null?void 0:c[n])}:{[n]:s()},a),[]),X=o.useCallback((n,s,a)=>u.current.updateVertex(c=>c?{...c,[n]:s}:{[n]:s},a),[]),Y=o.useCallback((n,s)=>{y(n,a=>a&&{...a,hasBeenTouched:!0},s),f(a=>a&&{...a,[n]:!0},s)},[f,y]),Z=o.useCallback((n,s)=>{y(n,a=>a&&{...a,hasBeenChanged:!0},s),p(a=>a&&{...a,[n]:!0},s)},[p,y]),M=o.useCallback(()=>{u.current.updateAllVertices(n=>n?Object.keys(n).reduce((s,a)=>({...s,[a]:{...n[a],changed:!1}}),{}):null),x(n=>n?Object.keys(n).reduce((s,a)=>({...s,[a]:!1}),{}):null)},[x]),$=o.useCallback(n=>{const s=u.current.getVertex(n);if(s){const a=Object.keys(s).reduce((C,h)=>{var k,F,j,O;return{...C,...(F=(k=s[h])==null?void 0:k.ref)!=null&&F.current||(O=(j=s[h])==null?void 0:j.options)!=null&&O.shouldNotBeAutoPruned?{[h]:s[h]}:{}}},{});u.current.setVertex(a,n);const c=C=>C?Object.keys(a).reduce((h,k)=>({...h,[k]:C[k]}),{}):null;V(c),f(c),p(c)}},[p,V,f]),G=o.useCallback(n=>{u.current.pruneAtCoordinates(n),d(n),I(n),w(n)},[w,d,I]),ae=o.useCallback((n,s)=>{u.current.updateVertex(c=>c?B(c,n):null,s);const a=u.current.getVertex(s);!a||Object.keys(a).length===0?G(s):(V(c=>c?B(c,n):null,s),f(c=>c?B(c,n):null,s),p(c=>c?B(c,n):null,s))},[G,p,V,f]),ce=o.useCallback(n=>{u.current.pruneAtCoordinates(n),_(n),R(n),Q(n)},[Q,_,R]),S=o.useCallback(()=>{u.current.forEachVertex((n,s)=>{if(!n)G(s);else{$(s);const a=u.current.getVertex(s);(!a||Object.keys(a).length===0)&&G(s)}})},[G,$]),T=o.useCallback((n,s)=>{var k,F;const a=u.current.getVertex(s);if(!(a&&n in a))return null;const c=a[n],C=se(c),h=c.options;if(h!=null&&h.isRequired&&re(C)){const j=((k=c.options)==null?void 0:k.isRequiredErrorMessageOverride)??e??"Field is required";return y(n,O=>({...O,error:j}),s),j}else{const j=K(u.current),O={...j.getVertex(s),[n]:C},ee=((F=h==null?void 0:h.validate)==null?void 0:F.call(h,C,O,j.get()))??null;return y(n,he=>({...he,error:ee}),s),ee}},[e,y]),P=o.useCallback(()=>u.current.forEachVertex((n,s)=>{n&&Object.keys(n).forEach(a=>T(a,s))}),[T]),m=o.useCallback((n,s)=>{V(a=>({...a,[n]:T(n,s)}),s)},[V,T]),N=o.useCallback(()=>{P();const n=u.current.mapAllVertices(s=>s?Object.keys(s).reduce((a,c)=>{var C;return{...a,[c]:(C=s[c])==null?void 0:C.error}},{}):null).get();l(n)},[l,P]),le=o.useCallback(({shouldSkipValidations:n,onSubmit:s,onError:a})=>{if(r||S(),n){const c=K(u.current);s==null||s(c),M()}else if(u.current){N();const c=u.current.mapAllVertices(h=>h?Object.keys(h).reduce((k,F)=>({...k,[F]:h[F].error}),{}):null);if(c.someVertex(h=>h?Object.keys(h).some(k=>h[k]!==null):!1))a==null||a(c);else{const h=K(u.current);M(),s==null||s(h)}}},[M,r,S,N]);return{register:o.useCallback((n,s)=>{s??(s={});const a=u.current.getVertex(s.coordinates)??{};return n in a?y(n,c=>({...c,options:s}),s.coordinates):X(n,{name:n,ref:Ve.createRef(),options:s,value:void 0,error:null,hasBeenTouched:!1,hasBeenChanged:!1},s==null?void 0:s.coordinates),{ref:c=>{const C=u.current.getVertex(s.coordinates);if(C!=null&&C[n])if(C[n].value===void 0){const h=Ce(c);y(n,k=>({...k,value:h,ref:{...k.ref,current:c}}),s.coordinates)}else y(n,h=>({...h,ref:{...h.ref,current:c}}),s.coordinates)},onChange:c=>{const C=u.current.getVertex(s.coordinates);if(n in C){C[n].hasBeenChanged||Z(n,s.coordinates);const h=xe(c);y(n,k=>({...k,value:h}),s==null?void 0:s.coordinates)}},onFocus:()=>{const c=u.current.getVertex(s.coordinates);n in c&&(c[n].hasBeenTouched||Y(n,s==null?void 0:s.coordinates))},onBlur:()=>{m(n,s==null?void 0:s.coordinates)}}},[Z,X,Y,m,y]),deregister:ae,deregisterAtCoordinates:ce,errors:A,touched:v,changed:D,hasBegun:ne,hasChangedWithoutSubmit:ue,handleSubmit:le}};export{fe as b,we as u};
